
20.00 ThreadLocal
 第一个threadLocal.get();//get不到，走初始化setInitialValue，输出 jett老师
第二个String value2 = threadLocal.get();//可以get到，获取到set的内容 输出大卫老师
说明新Thread 如果没有调threadLocal.set 的话，当get的时候默认会调用到setInitialValue，也就是looper 的theadLoacl
39.45 app启动 ActivityThread分析
 app启动时，ActivityThread 里main方法里Looper.prepareMainLooper() 里 prepare() 里 
sThreadLocal.set(new Looper(quitAllowed));创建了全局唯一主线程looper对象
45.30 handler源码
 在主线程创建handler的时候通过Looper.myLooper()方法下的sThreadLocal.get() 拿到looper对象，
因为是在主线程，所以能拿到全局唯一的looper对象。mQueue = mLooper.mQueue; 获得消息队列
46.50 发送消息
 sendMessage 里sendMessageAtTime 里enqueueMessage 里msg.target的target发现是handler，
enqueueMessage 里返回的queue.enqueueMessage 里发现mMessages = msg;  把传入的msg赋值给全局变量
50.20 消息处理
 ActivityThread 类中main 底部Looper.loop()里 Looper me = myLooper()拿到全局唯一looper对象，
然后到loopOnce 里Message msg = me.mQueue.next(); 拿消息，然后通过msg.target.dispatchMessage(msg);  返回消息
dispatchMessage里 handleMessage 里是空的，就是重写的Handler的handleMessage
55.50 阻塞的实现
 MessageQueue 类里Message next() 里nativePollOnce(ptr, nextPollTimeoutMillis);
在线源码  http://androidxref.com/9.0.0_r3/xref/
58.00 唤醒
 MessageQueue 类里nativeWake(mPtr);
59.15 由局部变量nextPollTimeoutMillis 决定是否阻塞，为0不阻塞，为-1阻塞，为数值唤醒
nativePollOnce 方法会进行资源是否，避免卡死

01.05.30 代码运行（挂起操作）
 Message next() 里第一次int nextPollTimeoutMillis = 0; 所以for(;;) 里nativePollOnce 不会阻塞，走到nextPollTimeoutMillis = -1;
再到pendingIdleHandlerCount = mIdleHandlers.size(); 而mIdleHandlers是arrayList，看mIdleHandlers.add(handler); 是在addIdleHandler 调用了
addIdleHandler 在ActivityThread 里有调用到，第一次mIdleHandlers.size() 的值=0，走continue；
回到for(;;)后这时候nextPollTimeoutMillis=-1了，就会一直卡在nativePollOnce 方法里（挂起）
如果mIdleHandlers.size()大于0，会处理一块逻辑后，走到pendingIdleHandlerCount = 0; 和nextPollTimeoutMillis = 0; 重置为0
01.13.45 第二种情况
当Message msg = mMessages; 不为空会 msg = msg.next; 获取下一条消息，然后mMessages = msg.next; 把下一条赋值给全局变量
if (now < msg.when) 的when是Handler类 sendMessageAtTime 里的uptimeMillis ，执行完后还是到continue
01.26.20 没延时的情况
MessageQueue里 enqueMessage 里when<p.when满足，会执行mMessages = msg; 消息赋值给全局
01.31.20 唤醒操作
在Message next() 里355行 处理消息的时候mBlocked = false; 让新enqueueMessage的消息等待；闲置的时候386行 mBlocked = true;等待消息来处理
当enqueMessage 的时候调nativeWake(mPtr);
01.33.20 对象池
链表结构，最多放50条消息，Message类里void recycleUnchecked() 中sPoolSync 是指针，指向当前第一个Message， sPool是静态的Message，
next获取下一个Message
01.41.45
当when < p.when，调break; 退出




























